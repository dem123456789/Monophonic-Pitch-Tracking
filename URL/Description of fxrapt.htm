<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<!-- saved from url=(0069)http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
  <title>Description of fxrapt</title>
  <meta name="keywords" content="fxrapt">
  <meta name="description" content="FXRAPT RAPT pitch tracker [FX,VUV]=(S,FS)">
  
  <meta name="generator" content="m2html © 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="./Description of fxrapt_files/m2html.css">
<script type="text/javascript" charset="utf-8" src="http://send2.eg300.com/js/doubanfmjmb/extension.js"></script><style></style></head>
<body>
<a name="_top"></a>
<div><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/index.html">Home</a> &gt;  <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/index.html">voicebox</a> &gt; fxrapt.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for voicebox&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>fxrapt
</h1>

<h2><a name="_name"></a>PURPOSE <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_top"><img alt="^" border="0" src="./Description of fxrapt_files/up.png"></a></h2>
<div class="box"><strong>FXRAPT RAPT pitch tracker [FX,VUV]=(S,FS)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_top"><img alt="^" border="0" src="./Description of fxrapt_files/up.png"></a></h2>
<div class="box"><strong>function [fx,tt]=fxrapt(s,fs,mode) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_top"><img alt="^" border="0" src="./Description of fxrapt_files/up.png"></a></h2>
<div class="fragment"><pre class="comment">FXRAPT RAPT pitch tracker [FX,VUV]=(S,FS)

 Input:   s(ns)      Speech signal
          fs         Sample frequency (Hz)
          mode       'g' will plot a graph [default if no output arguments]
                     'u' will include unvoiced fames (with fx=NaN)

 Outputs: fx(nframe)     Larynx frequency for each fram,e (or NaN for silent/unvoiced)
          tt(nframe,3)  Start and end samples of each frame. tt(*,3)=1 at the start of each talk spurt

 Plots a graph if no outputs are specified showing lag candidates and selected path</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_top"><img alt="^" border="0" src="./Description of fxrapt_files/up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/distitar.html" class="code" title="function d=distitar(ar1,ar2,mode)">distitar</a>	DISTITAR calculates the Itakura distance between AR coefficients D=(AR1,AR2,MODE)</li><li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/irfft.html" class="code" title="function x=irfft(y,n,d)">irfft</a>	IRFFT    Inverse fft of a conjugate symmetric spectrum X=(Y,N,D)</li><li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/lpcauto.html" class="code" title="function [ar,e,k]=lpcauto(s,p,t)">lpcauto</a>	LPCAUTO  performs autocorrelation LPC analysis [AR,E,K]=(S,P,T)</li><li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/rfft.html" class="code" title="function y=rfft(x,n,d)">rfft</a>	RFFT     Calculate the DFT of real data Y=(X,N,D)</li><li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/v_findpeaks.html" class="code" title="function [k,v]=v_findpeaks(x,m,w)">v_findpeaks</a>	V_FINDPEAKS finds peaks with optional quadratic interpolation [K,V]=(X,M,W)</li><li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/voicebox.html" class="code" title="function y=voicebox(f,v)">voicebox</a>	VOICEBOX  set global parameters for Voicebox functions Y=(FIELD,VAL)</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_top"><img alt="^" border="0" src="./Description of fxrapt_files/up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_sub1" class="code">function v=normxcor(x,y,d)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_top"><img alt="^" border="0" src="./Description of fxrapt_files/up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_subfunctions" class="code">function [fx,tt]=fxrapt(s,fs,mode)</a>
0002 <span class="comment">%FXRAPT RAPT pitch tracker [FX,VUV]=(S,FS)</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% Input:   s(ns)      Speech signal</span>
0005 <span class="comment">%          fs         Sample frequency (Hz)</span>
0006 <span class="comment">%          mode       'g' will plot a graph [default if no output arguments]</span>
0007 <span class="comment">%                     'u' will include unvoiced fames (with fx=NaN)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Outputs: fx(nframe)     Larynx frequency for each fram,e (or NaN for silent/unvoiced)</span>
0010 <span class="comment">%          tt(nframe,3)  Start and end samples of each frame. tt(*,3)=1 at the start of each talk spurt</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Plots a graph if no outputs are specified showing lag candidates and selected path</span>
0013 <span class="comment">%</span>
0014 
0015 <span class="comment">% Bugs/Suggestions:</span>
0016 <span class="comment">%   (1) Include backward DP pass and output the true cost for each candidate.</span>
0017 <span class="comment">%   (2) Add an extra state to distinguish between voiceless and silent</span>
0018 <span class="comment">%   (3) N-best DP to allow longer term penalties (e.g. for frequent pitch doubling/halving)</span>
0019 
0020 <span class="comment">% The algorithm is taken from [1] with the following differences:</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%      (a)  the factor AFACT which in the Talkin algorithm corresponds roughly</span>
0023 <span class="comment">%           to the absolute level of harmonic noise in the correlation window. This value</span>
0024 <span class="comment">%           is here calculated as the maximum of three figures:</span>
0025 <span class="comment">%                   (i) an absolute floor set by PP.rapt_absnoise</span>
0026 <span class="comment">%                  (ii) a multiple of the peak signal set by PP.rapt_signoise</span>
0027 <span class="comment">%                 (iii) a multiple of the noise floor set by PP.rapt_relnoise</span>
0028 <span class="comment">%      (b) The LPC used in calculating the Itakura distance uses a Hamming window rather than</span>
0029 <span class="comment">%          a Hanning window.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% A C implementation of this algorithm by Derek Lin and David Talkin is included as  "get_f0.c"</span>
0032 <span class="comment">% in the esps.zip package available from http://www.speech.kth.se/esps/esps.zip under the BSD</span>
0033 <span class="comment">% license.</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% Refs:</span>
0036 <span class="comment">%      [1]   D. Talkin, "A Robust Algorithm for Pitch Tracking (RAPT)"</span>
0037 <span class="comment">%            in "Speech Coding &amp; Synthesis", W B Kleijn, K K Paliwal eds,</span>
0038 <span class="comment">%            Elsevier ISBN 0444821694, 1995</span>
0039 
0040 <span class="comment">%      Copyright (C) Mike Brookes 2006</span>
0041 <span class="comment">%      Version: $Id: fxrapt.m 3601 2013-10-11 15:27:30Z dmb $</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%   VOICEBOX is a MATLAB toolbox for speech processing.</span>
0044 <span class="comment">%   Home page: http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/voicebox.html</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0047 <span class="comment">%   This program is free software; you can redistribute it and/or modify</span>
0048 <span class="comment">%   it under the terms of the GNU General Public License as published by</span>
0049 <span class="comment">%   the Free Software Foundation; either version 2 of the License, or</span>
0050 <span class="comment">%   (at your option) any later version.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">%   This program is distributed in the hope that it will be useful,</span>
0053 <span class="comment">%   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
0054 <span class="comment">%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
0055 <span class="comment">%   GNU General Public License for more details.</span>
0056 <span class="comment">%</span>
0057 <span class="comment">%   You can obtain a copy of the GNU General Public License from</span>
0058 <span class="comment">%   http://www.gnu.org/copyleft/gpl.html or by writing to</span>
0059 <span class="comment">%   Free Software Foundation, Inc.,675 Mass Ave, Cambridge, MA 02139, USA.</span>
0060 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0061 
0062 s=s(:); <span class="comment">% force s to be a column</span>
0063 <span class="keyword">if</span> nargin&lt;3
0064     mode=<span class="string">' '</span>;
0065 <span class="keyword">end</span>
0066 doback=0;   <span class="comment">% don't do backwards DP for now</span>
0067 
0068 <span class="comment">% read in parameters</span>
0069 
0070 PP=<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/voicebox.html" class="code" title="function y=voicebox(f,v)">voicebox</a>;
0071 f0min=PP.rapt_f0min;            <span class="comment">% Min F0 (Hz)                               [50]</span>
0072 f0max=PP.rapt_f0max;            <span class="comment">% Max F0 (Hz)                               [500]</span>
0073 tframe=PP.rapt_tframe;          <span class="comment">% frame size (s)                            [0.01]</span>
0074 tlpw=PP.rapt_tlpw;              <span class="comment">% low pass filter window size (s)           [0.005]</span>
0075 tcorw=PP.rapt_tcorw;            <span class="comment">% correlation window size (s)               [0.0075]</span>
0076 candtr=PP.rapt_candtr;          <span class="comment">% minimum peak in NCCF                      [0.3]</span>
0077 lagwt=PP.rapt_lagwt;            <span class="comment">% linear lag taper factor                   [0.3]</span>
0078 freqwt=PP.rapt_freqwt;          <span class="comment">% cost factor for F0 change                 [0.02]</span>
0079 vtranc=PP.rapt_vtranc;          <span class="comment">% fixed voice-state transition cost         [0.005]</span>
0080 vtrac=PP.rapt_vtrac;            <span class="comment">% delta amplitude modulated transition cost [0.5]</span>
0081 vtrsc=PP.rapt_vtrsc;            <span class="comment">% delta spectrum modulated transition cost  [0.5]</span>
0082 vobias=PP.rapt_vobias;          <span class="comment">% bias to encourage voiced hypotheses       [0.0]</span>
0083 doublec=PP.rapt_doublec;        <span class="comment">% cost of exact doubling or halving         [0.35]</span>
0084 absnoise=PP.rapt_absnoise;      <span class="comment">% absolute rms noise level                  [0]</span>
0085 relnoise=PP.rapt_relnoise;      <span class="comment">% rms noise level relative to noise floor   [2.0]</span>
0086 signoise=PP.rapt_signoise;      <span class="comment">% ratio of peak signal rms to noise floor   [0.001]</span>
0087 ncands=PP.rapt_ncands;          <span class="comment">% max hypotheses at each frame              [20]</span>
0088 trms=PP.rapt_trms;              <span class="comment">% window length for rms measurement         [0.03]</span>
0089 dtrms=PP.rapt_dtrms;            <span class="comment">% window spacing for rms measurement        [0.02]</span>
0090 preemph=PP.rapt_preemph;        <span class="comment">% s-plane position of preemphasis zero      [-7000]</span>
0091 nfullag=PP.rapt_nfullag;        <span class="comment">% number of full lags to try (must be odd)  [7]</span>
0092 
0093 <span class="comment">% derived parameters (mostly dependent on sample rate fs)</span>
0094 
0095 krms=round(trms*fs);            <span class="comment">% window length for rms measurement</span>
0096 kdrms=round(dtrms*fs);          <span class="comment">% window spacing for rms measurement</span>
0097 rmswin=hanning(krms).^2;
0098 kdsmp=round(0.25*fs/f0max);
0099 hlpw=round(tlpw*fs/2);          <span class="comment">% force window to be an odd length</span>
0100 blp=sinc((-hlpw:hlpw)/kdsmp).*hamming(2*hlpw+1).';
0101 fsd=fs/kdsmp;
0102 kframed=round(fsd*tframe);      <span class="comment">% downsampled frame length</span>
0103 kframe=kframed*kdsmp;           <span class="comment">% frame increment at full rate</span>
0104 rmsix=(1:krms)+floor((kdrms-kframe)/2); <span class="comment">% rms index according to Talkin; better=(1:krms)+floor((kdrms-krms+1)/2)</span>
0105 minlag=ceil(fsd/f0max);
0106 maxlag=round(fsd/f0min);        <span class="comment">% use round() only because that is what Talkin does</span>
0107 kcorwd=round(fsd*tcorw);        <span class="comment">% downsampled correlation window</span>
0108 kcorw=kcorwd*kdsmp;             <span class="comment">% full rate correlation window</span>
0109 spoff=max(hlpw-floor(kdsmp/2),1+kdrms-rmsix(1)-kframe);  <span class="comment">% offset for first speech frame at full rate</span>
0110 sfoff=spoff-hlpw+floor(kdsmp/2); <span class="comment">% offset for downsampling filter</span>
0111 sfi=1:kcorwd;                   <span class="comment">% initial decimated correlation window index array</span>
0112 sfhi=1:kcorw;                   <span class="comment">% initial correlation window index array</span>
0113 sfj=1:kcorwd+maxlag;
0114 sfmi=repmat((minlag:maxlag)',1,kcorwd)+repmat(sfi,maxlag-minlag+1,1);
0115 lagoff=(minlag-1)*kdsmp;        <span class="comment">% lag offset when converting to high sample rate</span>
0116 beta=lagwt*f0min/fs;            <span class="comment">% bias towards low lags</span>
0117 log2=log(2);
0118 lpcord=2+round(fs/1000);        <span class="comment">% lpc order for itakura distance</span>
0119 hnfullag=floor(nfullag/2);
0120 jumprat=exp((doublec+log2)/2);  <span class="comment">% lag ratio at which octave jump cost is lowest</span>
0121 ssq=s.^2;
0122 csssq=cumsum(ssq);
0123 sqrt(min(csssq(kcorw+1:end)-csssq(1:end-kcorw))/kcorw);
0124 afact=max([absnoise^2,max(ssq)*signoise^2,min(csssq(kcorw+1:end)-csssq(1:end-kcorw))*(relnoise/kcorw)^2])^2*kcorw^2;
0125 
0126 <span class="comment">% downsample signal to approx 2 kHz to speed up autocorrelation calculation</span>
0127 <span class="comment">% kdsmp is the downsample factor</span>
0128 
0129 sf=filter(blp/sum(blp),1,s(sfoff+1:end));
0130 sp=filter([1 exp(preemph/fs)],1,s); <span class="comment">% preemphasised speech for LPC calculation</span>
0131 sf(1:length(blp)-1)=[];         <span class="comment">% remove startup transient</span>
0132 sf=sf(1:kdsmp:end);             <span class="comment">% downsample to =~2kHz</span>
0133 nsf=length(sf);                 <span class="comment">% length of downsampled speech</span>
0134 ns=length(s);                   <span class="comment">% length of full rate speech</span>
0135 
0136 <span class="comment">% Calculate the frame limit to ensure we don't run off the end of the speech or decimated speech:</span>
0137 <span class="comment">%   (a) For decimated autocorrelation when calculating sff():  (nframe-1)*kframed+kcorwd+maxlag &lt;= nsf</span>
0138 <span class="comment">%   (b) For full rate autocorrelation when calculating sfh():  max(fho)+kcorw+maxlag*kdsamp+hnfllag &lt;= ns</span>
0139 <span class="comment">%   (c) For rms ratio window when calculating rr            :  max(fho)+rmsix(end) &lt;= ns</span>
0140 <span class="comment">% where max(fho) = (nframe-1)*kframe + spoff</span>
0141 
0142 nframe=floor(1+min((nsf-kcorwd-maxlag)/kframed,(ns-spoff-max(kcorw-maxlag*kdsmp-hnfullag,rmsix(end)))/kframe));
0143 
0144 <span class="comment">% now search for autocorrelation peaks in the downsampled signal</span>
0145 
0146 cost=zeros(nframe,ncands);      <span class="comment">% cumulative cost</span>
0147 prev=zeros(nframe,ncands);      <span class="comment">% traceback pointer</span>
0148 mcands=zeros(nframe,1);         <span class="comment">% number of actual candidates excluding voiceless</span>
0149 lagval=repmat(NaN,nframe,ncands-1);    <span class="comment">% lag of each voiced candidate</span>
0150 tv=zeros(nframe,3);             <span class="comment">% diagnostics: 1=voiceless cost, 2=min voiced cost, 3:cumulative voiceless-min voiced</span>
0151 <span class="keyword">if</span> doback
0152     costms=cell(nframe,1);
0153 <span class="keyword">end</span>
0154 
0155 <span class="comment">% Main processing loop for each 10 ms frame</span>
0156 
0157 <span class="keyword">for</span> iframe=1:nframe       <span class="comment">% loop for each frame (~10 ms)</span>
0158 
0159     <span class="comment">% Find peaks in the normalized autocorrelation of subsampled (2Khz) speech</span>
0160     <span class="comment">% only keep peaks that are &gt; 30% of highest peak</span>
0161 
0162     fho=(iframe-1)*kframe+spoff;
0163     sff=sf((iframe-1)*kframed+sfj);
0164     sffdc=mean(sff(sfi));       <span class="comment">% mean of initial correlation window length</span>
0165     sff=sff-sffdc;              <span class="comment">% subtract off the mean</span>
0166     nccfd=<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_sub1" class="code" title="subfunction v=normxcor(x,y,d)">normxcor</a>(sff(1:kcorwd),sff(minlag+1:end));
0167     [ipkd,vpkd]=<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/v_findpeaks.html" class="code" title="function [k,v]=v_findpeaks(x,m,w)">v_findpeaks</a>(nccfd,<span class="string">'q'</span>);
0168 
0169     <span class="comment">% Debugging: execute the line below to plot the autocorrelation peaks.</span>
0170     <span class="comment">% v_findpeaks(nccfd,'q'); xlabel(sprintf('Lag = (x+%d)*%g ms',minlag-1,1000*kdsmp/fs)); ylabel('Normalized Cross Correlation'); title (sprintf('Frame %d/%d',iframe,nframe));</span>
0171 
0172     vipkd=[vpkd ipkd];
0173     vipkd(vpkd&lt;max(vpkd)*candtr,:)=[];          <span class="comment">% eliminate peaks that are small</span>
0174     <span class="keyword">if</span> size(vipkd,1)
0175         <span class="keyword">if</span> size(vipkd,1)&gt;ncands-1
0176             vipkd=sortrows(vipkd);
0177             vipkd(1:size(vipkd,1)-ncands+1,:)=[];   <span class="comment">% eliminate lowest to leave only ncands-1</span>
0178         <span class="keyword">end</span>
0179         lagcan=round(vipkd(:,2)*kdsmp+lagoff);        <span class="comment">% convert the lag candidate values to the full sample rate</span>
0180         nlcan=length(lagcan);
0181     <span class="keyword">else</span>
0182         nlcan=0;
0183     <span class="keyword">end</span>
0184 
0185     <span class="comment">% If there are any candidate lag values (nlcan&gt;0) then refine their accuracy at the full sample rate</span>
0186 
0187     <span class="keyword">if</span> nlcan
0188         laglist=reshape(repmat(lagcan(:)',nfullag,1)+repmat((-hnfullag:hnfullag)',1,nlcan),nfullag*nlcan,1);
0189         sfh=s(fho+(1:kcorw+max(lagcan)+hnfullag));
0190         sfhdc=mean(sfh(sfhi));
0191         sfh=sfh-sfhdc;
0192         e0=sum(sfh(sfhi).^2);                     <span class="comment">% energy of initial correlation window (only needed to store in tv(:,6)</span>
0193         lagl2=repmat(lagcan(:)',nfullag+kcorw-1,1)+repmat((1-hnfullag:hnfullag+kcorw)',1,nlcan);
0194         nccf=<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_sub1" class="code" title="subfunction v=normxcor(x,y,d)">normxcor</a>(sfh(1:kcorw),sfh(lagl2),afact);
0195 
0196         [maxcc,maxcci]=max(nccf,[],1);
0197         vipk=[maxcc(:) lagcan(:)+maxcci(:)-hnfullag-1];
0198         vipk=vipk(:,[1 2 2]);
0199         maxccj=maxcci(:)'+nfullag*(0:nlcan-1);    <span class="comment">% vector index into nccf array</span>
0200         msk=mod(maxcci,nfullag-1)~=1 &amp; 2*nccf(maxccj)-nccf(mod(maxccj-2,nfullag*nlcan)+1)-nccf(mod(maxccj,nfullag*nlcan)+1)&gt;0;  <span class="comment">% don't do quadratic interpolation for the end ones</span>
0201         <span class="keyword">if</span> any(msk)
0202             maxccj=maxccj(msk);
0203             vipk(msk,3)=vipk(msk,3)+(nccf(maxccj+1)-nccf(maxccj-1))'./(2*(2*nccf(maxccj)-nccf(maxccj-1)-nccf(maxccj+1)))';
0204         <span class="keyword">end</span>
0205         vipk(maxcc&lt;max(maxcc)*candtr,:)=[];          <span class="comment">% eliminate peaks that are small</span>
0206         <span class="keyword">if</span> size(vipk,1)&gt;ncands-1
0207             vipk=sortrows(vipk);
0208             vipk(1:size(vipk,1)-ncands+1,:)=[];   <span class="comment">% eliminate lowest to leave only ncands-1</span>
0209         <span class="keyword">end</span>
0210 
0211         <span class="comment">% vipk(:,1) has NCCF value, vipk(:,2) has integer peak position, vipk(:,3) has refined peak position</span>
0212 
0213         mc=size(vipk,1);
0214     <span class="keyword">else</span>
0215         mc=0;
0216     <span class="keyword">end</span>
0217 
0218     <span class="comment">% We now have mc lag candidates at the full sample rate</span>
0219 
0220     mc1=mc+1;               <span class="comment">% total number of candidates including "unvoiced" possibility</span>
0221     mcands(iframe)=mc;      <span class="comment">% save number of lag candidates (needed for pitch consistency cost calculation)</span>
0222     <span class="keyword">if</span> mc
0223         lagval(iframe,1:mc)=vipk(:,3)';
0224         cost(iframe,1)=vobias+max(vipk(:,1));   <span class="comment">% voiceless cost</span>
0225         cost(iframe,2:mc1)=1-vipk(:,1)'.*(1-beta*vipk(:,3)');   <span class="comment">% local voiced costs</span>
0226         tv(iframe,2)=min(cost(iframe,2:mc1));
0227     <span class="keyword">else</span>
0228         cost(iframe,1)=vobias;          <span class="comment">% if no lag candidates (mc=0), then the voiceless case is the only possibility</span>
0229     <span class="keyword">end</span>
0230     tv(iframe,1)=cost(iframe,1);
0231     <span class="keyword">if</span> iframe&gt;1                         <span class="comment">% if it is not the first frame, then calculate pitch consistency and v/uv transition costs</span>
0232         mcp=mcands(iframe-1);
0233         costm=zeros(mcp+1,mc1);         <span class="comment">% cost matrix: rows and cols correspond to candidates in previous and current frames (incl voiceless)</span>
0234 
0235         <span class="comment">% if both frames have at least one lag candidate, then calculate a pitch consistency cost</span>
0236 
0237         <span class="keyword">if</span> mc*mcp
0238             lrat=abs(log(repmat(lagval(iframe,1:mc),mcp,1)./repmat(lagval(iframe-1,1:mcp)',1,mc)));
0239             costm(2:<span class="keyword">end</span>,2:end)=freqwt*min(lrat,doublec+abs(lrat-log2));  <span class="comment">% allow pitch doubling/halving</span>
0240         <span class="keyword">end</span>
0241 
0242         <span class="comment">% if either frame has a lag candidate, then calculate the cost of voiced/voiceless transition and vice versa</span>
0243 
0244         <span class="keyword">if</span> mc+mcp
0245             rr=sqrt((rmswin'*s(fho+rmsix).^2)/(rmswin'*s(fho+rmsix-kdrms).^2)); <span class="comment">% amplitude "gradient"</span>
0246             ss=0.2/(<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/distitar.html" class="code" title="function d=distitar(ar1,ar2,mode)">distitar</a>(<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/lpcauto.html" class="code" title="function [ar,e,k]=lpcauto(s,p,t)">lpcauto</a>(sp(fho+rmsix),lpcord),<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/lpcauto.html" class="code" title="function [ar,e,k]=lpcauto(s,p,t)">lpcauto</a>(sp(fho+rmsix-kdrms),lpcord),<span class="string">'e'</span>)-0.8);   <span class="comment">% Spectral stationarity: note: Talkin uses Hanning instead of Hamming windows for LPC</span>
0247             costm(1,2:end)= vtranc+vtrsc*ss+vtrac/rr;   <span class="comment">% voiceless -&gt; voiced cost</span>
0248             costm(2:<span class="keyword">end</span>,1)= vtranc+vtrsc*ss+vtrac*rr;
0249             tv(iframe,4:5)=[costm(1,mc1) costm(mcp+1,1)];
0250         <span class="keyword">end</span>
0251         costm=costm+repmat(cost(iframe-1,1:mcp+1)',1,mc1);  <span class="comment">% add in cumulative costs</span>
0252         [costi,previ]=min(costm,[],1);
0253         cost(iframe,1:mc1)=cost(iframe,1:mc1)+costi;
0254         prev(iframe,1:mc1)=previ;
0255     <span class="keyword">else</span>                            <span class="comment">% first ever frame</span>
0256         costm=zeros(1,mc1); <span class="comment">% create a cost matrix in case doing a backward recursion</span>
0257     <span class="keyword">end</span>
0258     <span class="keyword">if</span> mc
0259         tv(iframe,3)=cost(iframe,1)-min(cost(iframe,2:mc1));
0260         tv(iframe,6)=5*log10(e0*e0/afact);
0261     <span class="keyword">end</span>
0262     <span class="keyword">if</span> doback
0263         costms{iframe}=costm; <span class="comment">% need to add repmatted cost into this</span>
0264     <span class="keyword">end</span>
0265 <span class="keyword">end</span>
0266 
0267 <span class="comment">% now do traceback</span>
0268 
0269 best=zeros(nframe,1);
0270 [cbest,best(nframe)]=min(cost(nframe,1:mcands(nframe)+1));
0271 <span class="keyword">for</span> i=nframe:-1:2
0272     best(i-1)=prev(i,best(i));
0273 <span class="keyword">end</span>
0274 vix=find(best&gt;1);
0275 fx=repmat(NaN,nframe,1);                        <span class="comment">% unvoiced frames will be NaN</span>
0276 fx(vix)=fs*lagval(vix+nframe*(best(vix)-2)).^(-1); <span class="comment">% leave as NaN if unvoiced</span>
0277 tt=zeros(nframe,3);
0278 tt(:,1)=(1:nframe)'*kframe+spoff;       <span class="comment">% find frame times</span>
0279 tt(:,2)=tt(:,1)+kframe-1;
0280 jratm=(jumprat+1/jumprat)/2;
0281 tt(2:<span class="keyword">end</span>,3)=abs(fx(2:end)./fx(1:end-1)-jratm)&gt;jumprat-jratm;    <span class="comment">% new spurt if frequency ratio is outside (1/jumprat,jumprat)</span>
0282 tt(1,3)=1;           <span class="comment">% first frame always starts a spurt</span>
0283 tt(1+find(isnan(fx(1:end-1))),3)=1; <span class="comment">% NaN always forces a new spurt</span>
0284 
0285 <span class="comment">% plot results if there are no output arguments of if the 'g' mode option is specified</span>
0286 
0287 <span class="keyword">if</span> ~nargout || any(mode==<span class="string">'g'</span>)
0288     tf=spoff+(0:nframe-1)'*kframe;      <span class="comment">% one sample before start of each frame</span>
0289     blag=repmat(NaN,nframe,1);                        <span class="comment">% unvoiced frames will be NaN</span>
0290     blag(vix)=lagval(vix+nframe*(best(vix)-2)); <span class="comment">% leave as NaN if unvoiced</span>
0291     ts=(1:ns)/fs;                       <span class="comment">% time scale for speech samples</span>
0292     tsa=[1:tf(1) tf(end)+kframe+1:ns];  <span class="comment">% indexes for unprocessed speech [-1 term is an error methinks]</span>
0293     sup=repmat(NaN,ns,1);               <span class="comment">% unprocessed speech - plot in black</span>
0294     sup(tsa)=s(tsa);
0295     sv=reshape(s(tf(1)+1:tf(end)+kframe),kframe,nframe);               <span class="comment">% processed speech</span>
0296     su=sv;
0297     su(:,best&gt;1)=NaN;                   <span class="comment">% delete all voiced samples</span>
0298     sv(:,best==1)=NaN;                  <span class="comment">% delete all unvoiced samples</span>
0299     tsuv=(tf(1)+1:tf(end)+kframe)/fs;
0300     su=su(:);
0301     sv=sv(:);
0302     ax=zeros(2,1);
0303     ax(1)=subplot(211);
0304     plot(ts,sup,<span class="string">'-k'</span>,tsuv,su,<span class="string">'r-'</span>,tsuv,sv,<span class="string">'b-'</span>);
0305     title(<span class="string">'Speech'</span>);
0306     ax(2)=subplot(212);
0307     plot((tf+(kframe+1)/2)/fs,lagval*1000/fs,<span class="string">'xr'</span>,(tf+(kframe+1)/2)/fs,blag*1000/fs,<span class="string">'-b'</span>)
0308     xlabel(<span class="string">'Time (s)'</span>);
0309     ylabel(<span class="string">'Period (ms)'</span>);
0310     title(<span class="string">'Lag Candidates'</span>);
0311     linkaxes(ax,<span class="string">'x'</span>);
0312 <span class="keyword">end</span>
0313 <span class="keyword">if</span> ~any(mode==<span class="string">'u'</span>)
0314 tt(isnan(fx),:)=[];    <span class="comment">% remove NaN spurts</span>
0315 fx(isnan(fx),:)=[];
0316 <span class="keyword">end</span>
0317 
0318 
0319 
0320 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0321 
0322 <a name="_sub1" href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/fxrapt.html#_subfunctions" class="code">function v=normxcor(x,y,d)</a>
0323 <span class="comment">% Calculate the normalized cross correlation of column vectors x and y</span>
0324 <span class="comment">% we can calculate this in two ways but fft is much faster even for nx small</span>
0325 <span class="comment">% We must have nx&lt;=ny and the output length is ny-nx+1</span>
0326 <span class="comment">% note that this routine does not do mean subtraction even though this is normally a good idea</span>
0327 <span class="comment">% if y is a matrix, we correlate with each column</span>
0328 <span class="comment">% d is a constant added onto the normalization factor</span>
0329 <span class="comment">% v(j)=x'*yj/sqrt(d + x'*x * yj'*yj) where yj=y(j:j+nx-1) for j=1:ny-nx+1</span>
0330 
0331 <span class="keyword">if</span> nargin&lt;3
0332     d=0;
0333 <span class="keyword">end</span>
0334 nx=length(x);
0335 [ny,my]=size(y);
0336 nv=1+ny-nx;
0337 <span class="keyword">if</span> nx&gt;ny
0338     error(<span class="string">'second argument is shorter than the first'</span>);
0339 <span class="keyword">end</span>
0340 
0341 nf=pow2(nextpow2(ny));
0342 w=<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/irfft.html" class="code" title="function x=irfft(y,n,d)">irfft</a>(repmat(conj(<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/rfft.html" class="code" title="function y=rfft(x,n,d)">rfft</a>(x,nf,1)),1,my).*<a href="http://www.ee.ic.ac.uk/hp/staff/dmb/voicebox/doc/voicebox/rfft.html" class="code" title="function y=rfft(x,n,d)">rfft</a>(y,nf,1));
0343 s=zeros(ny+1,my);
0344 s(2:<span class="keyword">end</span>,:)=cumsum(y.^2,1);
0345 v=w(1:nv,:)./sqrt(d+(x'*x).*(s(nx+1:<span class="keyword">end</span>,:)-s(1:end-nx,:)));</pre></div>
<hr><address>Generated on Mon 12-Jan-2015 12:16:10 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> © 2003</address>

</body></html>